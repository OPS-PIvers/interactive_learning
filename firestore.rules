rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isValidProject() {
      let data = request.resource.data;
      return data.keys().hasAll(['title', 'description', 'createdBy']) &&
             data.title is string && data.title.size() <= 200 &&
             data.description is string && data.description.size() <= 1000 &&
             data.createdBy is string &&
             // Optional legacy fields
             (!data.keys().has('thumbnailUrl') || data.thumbnailUrl is string || data.thumbnailUrl == null) &&
             (!data.keys().has('backgroundImage') || data.backgroundImage is string || data.backgroundImage == null) &&
             (!data.keys().has('imageFitMode') || data.imageFitMode is string) &&
             (!data.keys().has('viewerModes') || data.viewerModes is map) &&
             // --- New Slide Deck Validation ---
             // The slideDeck field is optional. If it doesn't exist, this is true.
             // If it does exist, it must be a valid slide deck.
             (!data.keys().has('slideDeck') || (data.slideDeck is map && isValidSlideDeck(data.slideDeck)));
    }
    
    function isValidHotspot() {
      return request.resource.data.keys().hasAll(['x', 'y', 'title']) &&
             request.resource.data.x is number &&
             request.resource.data.y is number &&
             request.resource.data.x >= 0 && request.resource.data.x <= 100 &&
             request.resource.data.y >= 0 && request.resource.data.y <= 100 &&
             request.resource.data.title is string &&
             request.resource.data.title.size() <= 100;
    }
    
    function isValidTimelineEvent() {
      return request.resource.data.keys().hasAll(['step', 'name']) &&
             request.resource.data.step is number &&
             request.resource.data.step > 0 &&
             request.resource.data.name is string &&
             request.resource.data.name.size() <= 100;
    }

    // --- Slide-Based Architecture Validation Functions ---

    function isValidFixedPosition(pos) {
      return pos is map &&
             pos.keys().hasAll(['x', 'y', 'width', 'height']) &&
             pos.x is number && pos.y is number &&
             pos.width is number && pos.height is number;
    }

    function isValidResponsivePosition(pos) {
      return pos is map &&
             pos.keys().hasAll(['desktop', 'tablet', 'mobile']) &&
             isValidFixedPosition(pos.desktop) &&
             isValidFixedPosition(pos.tablet) &&
             isValidFixedPosition(pos.mobile);
    }

    function isValidSlideElement(element) {
      return element is map &&
             element.keys().hasAll(['id', 'type', 'position', 'content', 'style', 'isVisible']) &&
             element.id is string &&
             element.type is string &&
             (element.type == 'hotspot' || element.type == 'text' || element.type == 'media' || element.type == 'shape') &&
             isValidResponsivePosition(element.position) &&
             element.content is map && // Simplified check for content
             element.style is map &&   // Simplified check for style
             element.isVisible is bool;
    }

    function isValidInteractiveSlide(slide) {
      let elements = slide.get('elements', []);
      return slide is map &&
             slide.keys().hasAll(['id', 'title', 'elements', 'layout']) &&
             slide.id is string &&
             slide.title is string &&
             slide.title.size() < 200 &&
             slide.elements is list &&
             (elements.size() == 0 || isValidSlideElement(elements[0])) && // Check first element as sample
             slide.layout is map; // Simplified check
    }

    function isValidDeckSettings(settings) {
        return settings is map &&
               settings.keys().hasAll(['autoAdvance', 'allowNavigation', 'showProgress', 'showControls']) &&
               settings.autoAdvance is bool &&
               settings.allowNavigation is bool &&
               settings.showProgress is bool &&
               settings.showControls is bool;
    }

    function isValidDeckMetadata(metadata) {
        return metadata is map &&
               metadata.keys().hasAll(['created', 'modified', 'version', 'isPublic']) &&
               metadata.created is number &&
               metadata.modified is number &&
               metadata.version is string &&
               metadata.isPublic is bool;
    }

    function isValidSlideDeck(deck) {
      let slides = deck.get('slides', []);
      return deck is map &&
             deck.keys().hasAll(['id', 'title', 'slides', 'settings', 'metadata']) &&
             deck.id is string &&
             deck.title is string &&
             deck.slides is list &&
             (slides.size() == 0 || isValidInteractiveSlide(slides[0])) && // Check first slide as a sample
             isValidDeckSettings(deck.settings) &&
             isValidDeckMetadata(deck.metadata);
    }
    
    // Projects collection - require authentication and ownership
    match /projects/{projectId} {
      allow read: if isAuthenticated() && isOwner(resource.data.createdBy) || resource.data.isPublished == true;
      
      allow create: if isAuthenticated() && 
                       isOwner(request.resource.data.createdBy) &&
                       isValidProject();
      
      allow update: if isAuthenticated() && 
                       isOwner(resource.data.createdBy) &&
                       isValidProject();
      
      allow delete: if isAuthenticated() && 
                       isOwner(resource.data.createdBy);
      
      // Hotspots subcollection
      match /hotspots/{hotspotId} {
        allow read: if (isAuthenticated() && 
                             isOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.createdBy)) || (get(/databases/$(database)/documents/projects/$(projectId)).data.isPublished == true);
        allow write: if isAuthenticated() && 
                             isOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.createdBy);
      }
      
      // Timeline events subcollection  
      match /timeline_events/{eventId} {
        allow read: if (isAuthenticated() && 
                             isOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.createdBy)) || (get(/databases/$(database)/documents/projects/$(projectId)).data.isPublished == true);
        allow write: if isAuthenticated() && 
                             isOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.createdBy);
      }
    }
    
    // User profiles collection
    match /users/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);
    }

    // Cross-device sync collection - used for real-time progress sharing
    // This allows the project owner to read/write to sync documents.
    // The rule ensures that a user can only access the sync data for projects they own.
    match /crossDeviceSync/{syncId} {
      allow read, write: if isAuthenticated() && get(/databases/$(database)/documents/projects/$(syncId)).data.createdBy == request.auth.uid;
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}